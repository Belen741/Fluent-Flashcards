ActÃºa como un desarrollador front-end senior. Vamos a mejorar el MVP existente (React) agregando una lÃ³gica interna de â€œrepeticiÃ³n invisibleâ€ para las flashcards, sin mostrar nada de spaced repetition al usuario.

OBJETIVO:
Que durante una sesiÃ³n, algunas tarjetas reaparezcan de forma camuflada segÃºn el desempeÃ±o del usuario, pero que la interfaz siga siendo simple: solo â€œSiguienteâ€, progreso y contenido.

REQUERIMIENTOS FUNCIONALES:

1) Modelo de datos
Actualiza los datos de flashcards para que cada tarjeta tenga:
- id: string
- text: string
- imageUrl: string
- audioUrl: string (placeholder)
- conceptId: string  (ej. "bp_01")  // identifica el concepto base
- variantType: "intro" | "cloze" | "mcq"  // tipo de variante (para camuflar repeticiÃ³n)

Incluye al menos 9 tarjetas en total, pero agrupadas en 3 conceptos (3 conceptos x 3 variantes).
Ejemplo:
concepto A: 3 variantes (intro/cloze/mcq)
concepto B: 3 variantes
concepto C: 3 variantes

2) Estado de aprendizaje (invisible)
Implementa un estado interno por conceptId:
- seenCountToday (nÃºmero)
- correctStreak (nÃºmero)
- lastSeenIndex (nÃºmero opcional)
- strength: "new" | "weak" | "strong"

Este estado NO se muestra en UI.

3) InteracciÃ³n mÃ­nima para medir desempeÃ±o
En la pantalla de flashcards, agrega SOLO esto:
- Dos botones pequeÃ±os debajo del contenido:
  "Lo supe" y "No lo supe"

Estos botones sirven para registrar si el usuario acertÃ³ o fallÃ³, pero SIN mostrar explicaciones.
Sigue existiendo el botÃ³n principal â€œSiguienteâ€.

Comportamiento:
- El usuario primero marca â€œLo supeâ€ o â€œNo lo supeâ€ (opcional).
- Al presionar â€œSiguienteâ€, avanzamos y guardamos el resultado (si no marcÃ³ nada, asumir â€œLo supeâ€).

4) Algoritmo de â€œrepeticiÃ³n camufladaâ€ para la cola de sesiÃ³n
Al iniciar la sesiÃ³n, en vez de mostrar simplemente la lista en orden, construye una â€œsessionQueueâ€ interna con estas reglas:

- Cada concepto debe aparecer 3 veces en la sesiÃ³n (una por variante), pero separadas entre sÃ­.
- Si el usuario marca â€œNo lo supeâ€ en un concepto:
   -> reinsertar (en la cola) otra variante del MISMO conceptId dentro de los prÃ³ximos 2-3 pasos,
      siempre que exista una variante no usada todavÃ­a.
- Si marca â€œLo supeâ€:
   -> no reinsertar pronto; mantener espaciado natural.

Reglas importantes:
- NO mostrar al usuario que es repeticiÃ³n.
- NO repetir exactamente la misma tarjeta consecutivamente.
- Preferir cambiar variantType cuando se repite (intro -> cloze -> mcq, etc.).
- Al terminar la cola, mostrar â€œSesiÃ³n completada ğŸ‰â€.

5) Persistencia (simple)
Guarda el estado interno en localStorage al finalizar sesiÃ³n:
- learningState por conceptId
- historial mÃ­nimo de la Ãºltima sesiÃ³n (fecha y conceptos vistos)

Pero NO construyas aÃºn un sistema de calendario o â€œdue datesâ€.
Solo persistencia bÃ¡sica.

6) CÃ³digo
- Refactoriza en componentes y archivos claros:
  /src/data/flashcards.ts
  /src/utils/sessionQueue.ts  (algoritmo)
  /src/components/FlashcardView.tsx
  /src/pages/Home.tsx
  /src/pages/Session.tsx
- AsegÃºrate de que compile y corra en Replit.

7) UI / UX
MantÃ©n el diseÃ±o minimalista como el MVP:
- fondo blanco
- texto grande
- progreso â€œTarjeta X de Yâ€
- NO stats avanzados
- NO â€œmodo repasoâ€
- NO tÃ©rminos tÃ©cnicos

ENTREGABLE:
- Aplica los cambios al cÃ³digo existente
- Explica brevemente dÃ³nde quedÃ³ cada cosa y cÃ³mo probarlo